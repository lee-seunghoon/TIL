## Numpy

> - 수치연산을 위한 파이썬 라이브러리 (Numeric Python)
> - 행렬 연산 기본
> - vector(1차원)나 matrix(2차원) 연산 편리성 제공
> - 넘파이 ==> 기본적인 자료구조 제공
> - ndarray(n-dimensional array) == n차원의 배열



## Numpy 생성

```python
import numpy as np

a = np.array([1,2,3,4,5])
b = [1,2,3,4,5]

print(a)
print(b)

print(type(a))
print(type(b))
```

`리스트와 넘파이 자료구조의 차이점 : ndarray는 모든 원소가 같은 데이터 type을 가져야 한다! & 리스트는 차원 개념이 없다`



## Numpy 구조 확인

```python
# 1차원
my_list = [1,2,3,4]
new_array = np.array(my_list)
print(new_array.dim)
print(new_array.shape)

# .dim ==> 차원의 수를 나타냄
# .shape ==> 각 차원과 요소의 개수를 tuple로 표현

# 2차원
my_list = [[1,2,3], [4,5,6]]
new_array = np.array(my_list)
print(new_array)
print(new_array.dim)
print(new_array.shape)

# 3차원
my_list = [[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]]
new_array = np.array(my_list)
print(new_array)
print(new_array.dim)
print(new_array.shape) # ==> (2,2,3) ==> 2면 2행 3열
```



## Numpy 구조 변경

```python
# 1차원 ndarray 생성
my_list = [1,2,3,4]
new_array = np.array(my_list)
print(new_array)
print(new_array.shape)

# 1차원 -> 2차원 변경
new_array.shape = (2,2)
print(new_array)
print(new_array.shape)

# 2차원 -> 3차원 변경
new_array.shape = (4,1,1)
print(new_array)
print(new_array.shape)
```

### reshape

> - 새로운 ndarray를 만들지 않는다.
> - 변수를 새로 만들었지만 새로 만들어졌다기 보다 view로 만든 것
> - 메모리 아끼기 위해서 새로운 메모리 저장 공간을 만들지 않는다.
> - -1을 사용해 계상 없이 쉽게 변경 가능!

```python
# reshape 활용
# 이걸 더 많이 활용해요
new_array = new_array.reshape(2,2)
print(new_array)
print(new_array.shape)

# 더 많은 데이터
arr = np.arange(12)
print(arr)

# 복사본
arr1 = arr.reshape(3,4) # ==> 3행 4열 2차원 ndarray
print(arr1)
'''
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
'''

# -1 활용 reshape
# '-1'의 의미는 남은 것을 자동으로 배열하겠다는 의미
# 3행으로 맞춰서 만들고 열은 행 맞춘거와 data 고려해서 자동으로 구성
arr1 = arr.reshape(3,-1) # ==> 3행 4열
print(arr1)

# 반대로 열을 3열로 맞추고, 행을 자동 구성
arr1 = arr.reshape(-1,3) # ==> 4행 3열
print(arr1)

# 3차원
arr1 = arr.reshape(2,3,-1) # ==> 2면 3행 2열 
print(arr1)
'''
[[[0 1]
  [2 3]
  [4 5]]
    
[[6 7]
 [8 9]
 [10 11]]]
'''
```

### resize

> - ndarray의 형태를 변경할 수 있다.
> - 결과를 return하지 않고 원본을 바꾼다.
> - arr.resize(1,6) ==> 원본이 바뀜
> - 새로운 변수로 만들고 싶을 때는 ==> arr1 = `np.resize`(arr, (1, 6))
> - reshape()와 다르게 형태가 안맞아도 바꿀 수 있다. ==> 나머지 추가 요소는 0으로 채워짐 ==> 새로 만드는 개념이라서

```python
arr = np.array([[1,2,3],[4,5,6]])
arr1 = arr.resize(1,6)
print(arr1)
# ==> 기대값 : [[1 2 3 4 5 6]]
# ==> 실제값 : None  / 왜냐면 arr.resize()는 arr을 바꾸는거라서 return 값이 없어

# 다르게 적용
arr1 = np.resize(arr, (1,6))  # 얘는 return 값이 있겠지
# ==> numpy가 가지고 있는 resize 이용할거야!
# ==> 위 arr.resize랑 다르다.
print(arr1) # ==> [1 2 3 4 5 6]]

# 원본에 적용
arr.resize(3,4)
print(arr)
'''
[[1 2 3 4]
 [5 6 0 0]
 [0 0 0 0]]
'''

# 위와 차이점이 느껴지는가 / np method로 줬을 때는 추가 요소에 arr 안에 있는 값을 circle 시킨다.
arr2 = np.resize(arr, (3,4)) # ==> 추가
print(arr2) # ==> np.resize()는 요소가 circle이 발생!
'''
[[1 2 3 4 5]
 [6 1 2 3 4]
 [5 6 1 2 3]]
 
# 버리는 것도 가능하다!
# 굉장히 유연함
arr3 = np.resize(arr, (2,2)) # ==> 버림
print(arr3)
'''
[[1 2]
 [3 4]]
'''

```



## Numpy 데이터 유형

> - ndarray의 data type을 변경
> - int32 --> float64

```python
arr = np.array([1.2, 2.3, 3.5, 5.4, 4.1, 5.7])
print(arr.dtype)  # ==> float64

arr = arr.astype(np.int32)
print(arr.dtype) # ==> int32
print(arr) # 정수로 바꿀 때 소수점 이하는 버린다.
# ==> [1 2 3 5 4 5]
```



## Numpy 유용한 함수 모음

> - np.arange()
> - ravel()

```python
# np.arange
arr = np.arange(0,11,2)
# 0부터 10까지 2씩 건너뀌어서 ndarray 생성
print(arr)
# ==> [ 0  2  4  6  8 10]

# # arange는 기본 1차원 형식으로만 만들 수 있다
# 그래서 기본 만들고 원하는 shape로 reshape 줘야 한다.
print(arr.reshape(2,3)) # reshape는 view만 생성!
'''
[[ 0  2  4]
 [ 6  8 10]]
'''

# ravel()
# 어떤 차원의 배열이든 무조건 1차원으로 바꾼다.
# 이것도 copy된게 아니라 view가 return 된다!
arr1 = arr.ravel()
print(arr1)
# ==> [0  2  4  6  8 10]

```

### random ndarray

> - np.random.normal()

```python
# np.random.normal()
# 정규분포에서 실수형태 난수를 추출

import numpy as np
import matplotlib.pyplot as plt
# matplotlib 모듈 안에 있는 pyplot 클래스 이용

my_mean = 50 # 평균값
my_std = 2   # 표준편차

# 1차원 형태로 평균 50, 표준편차 2의 정규분포에 속한 난수를 추출한다
arr = np.random.normal(my_mean, my_std, (1000,)) 
# (평균, 표준편차, 요소개수 몇개 줄건지)
print(arr)
# ==> [48.79017376 52.94437454 46.62254331 ... 50.45626116 50.34343596 48.44195045]

# 위 수치를 히스토그램으로 그려보기
plt.hist(arr, bins=100)
# bins = 최대값과 최소값 사이를 100 영역으로 쪼갠다.
plt.show # ==> 그래프 출력하는 명령어
```

