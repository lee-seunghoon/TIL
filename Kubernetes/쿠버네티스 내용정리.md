# 쿠버네티스란?

- 컨테이너화된 워크로드와 서비스 관리하기 위한 오픈소스 플랫폼
- 컨테이너 `오케스트레이션`
- 구글
- Kubernetes ==> `k8s`



## 가상머신 vs 컨테이너

### 가상머신

> - infrastructure 위 Hypervisor(호스트 운영체제 포함)를 얹고 그 위에 하드웨어 기반의 가상머신(VM)을 올린다.
> - 가상 머신은 리소스가 더 필요할 때마다 그에 맞는 `하드웨어`를 세팅해줘야 한다.
> - 가상머신에는 `목적`에 따라 어플리케이션이 따로 존재한다(웹서버, 결제, 장바구니 등) == 즉, 가상머신 간에 어플리케이션을 `격리`하고 어플리케이션 간에 자유롭게 액세스 하기 어렵도록 일정 수준의 `보안성` 제공
> - 유연하게 각 기능에 맞게 필요한 리소스에 맞게 하드웨어 환경은 주고 빼고 할 수 있다.
> - 문제는 만약 웹서버 어플리케이션 하나가 다운되면 우리 사이트는 바로 Die 그래서 `Horizontal`하게 여러 웹서버 가상머신을 구축해준다.



### 컨테이너

> - 동일하게 infrastructure 위에 Host Operation(호스트 운영체제)를 올리고 그 위에 `Docker` 컨테이너 플랫폼을 올리고 그 위에 각 기능을 담당하는 어플리케이션을 올린다.
> - 가상머신과 차이점은 `소스코드`와 `베이스 환경`만 있는 상황에서 동작시킨다. 이 말은 가상머신은 100MB의 어플리케이션을 운영하기 위해서 1~3GB 정도의 guest OS가 필요한데 컨테이너는 애플리케이션 간에 OS를 공유해서 가볍다.
> - 기본 인프라와 `종속성`을 끊었기(컨테이너는 자체 파일 시스템, CPU점유율, 메모리, 프로세스 공간 등이 있다.) 때문에 다른 클라우드나 OS 배포본에 모두 이식할 수 있다. (`이식성(portable/ Ubuntu, 온프레미스, 주요 퍼블릭 클라우드)`)
> - 컨테이너의 주 목적은 `빠른 배포(deploy)` 및 `지속적인 통합 및 배포` (안정적이고 주기적인 컨테이너 이미지 빌드)
> - `독립된 공간`에서 실행
> - 가볍게 실행할 수 있어서 빠르게 확장 축소 가능!

![Docker와 VM. Docker를 공부하면 가장 처음 등장하는 내용이 바로 `docker… | by 서강혁 | Medium](https://miro.medium.com/max/862/1*wOBkzBpi1Hl9Nr__Jszplg.png)



## 멀티호스트 도커 플랫폼

> - 완전한 기능을 담고있는 하나의 도커를 여러개로 만들 수 있고, 각 도커 안에 필요한 어플리케이션 자원을 `독립적`으로 세팅할 수 있다.
> - 하지만 각 도커마다 할당할 자원과 균등 배분을 `수동`으로 하는 것은 매우 비효율적이다.
> - 엔지니어가 모든 자원을 직접 배치하고 관리하는 작업은 어렵다(특히, `Micro-Sercive Architecture` 지향의 프로그램은 더더욱!)
> - 그래서 등장한 게 `컨테이너 오케스트레이션(쿠버네티스)`

![image-20220303162544305](C:\Users\dad04\Desktop\LSH\TIL\Kubernetes\md-images\image-20220303162544305.png)



## 컨테이너 오케스트레이션(쿠버네티스)

> - 도커 위에서 배치할 어플리케이션을 `자동`으로 `최적화` 해서 `자동 관리`해주는 느낌
> - 각  `work node`를 관리해준다.
> - 각 상황에 맞게 `확장, 축소`도 알아서 도와주고, 하나의 도커 서비스가 다운 될 때도 다른 도커로 이동해서 사용할 수 있게끔 도와준다.
> - `쿠버네티스`는 컨테이너화된 어플리케이션을 `자동`으로 `배포, 스케일링 및 관리`해주는 오픈소스 시스템(from Google)
> - 쿠버네티스는 `조타수` 라는 의미를 가지고 있다.
> - `CNCF` 는 혼란스런 컨테이너화된 시스템을 오픈소스로 해결하고자 하는 컨퍼런스 비영리 조직

![Untitled](C:\Users\dad04\Desktop\LSH\TIL\Kubernetes\md-images\Untitled.png)





## 쿠버네티스 특징

> - `로드 밸런싱`(네트워크 트래픽 조정, 안정적인 배포)
>
> - `자동 복구`(self-healing) : 실패한 컨테이너 다시 시작 및 교체 가능(서비스 준비 완료될 때까지 클라이언트에게 실패를 보여주지 않는다.)
>
> - `bin packing 자동화` : 컨테이너 마다 필요한 CPU & 메모리(RAM)를 쿠버네티스가 지시한다.
>
>   각 노드에 맞춰 리소스를 최적화하여 분배하고, 사용할 수 있게끔 도와준다.
>
> - loosely coupled, 분산, 유연한 MSA : 어플리케이션은 모놀리식 스택으로 구성 X
>
> - 어디서나 실행 가능하다. 
>   - 온프레미스(사내 서버 pc에 직접 도커 세팅)
>   - 퍼블릭 클라우드(AKS, GKS, EKS 등)
>   
> - `선언적 API` ▶ 이 특징 때문에 `DevOps`가 가능하다





## 쿠버네티스 중요 개념



#### 선언적 API

- 요구사항을 선언해주면 알아서 진행해주는 방식
- 선언해준대로 최적화해서 자동으로 실행하다가 문제 발생하면 또 다시 바꿔주고 세팅해주는 방식

![Untitled 2](C:\Users\dad04\Desktop\LSH\TIL\Kubernetes\md-images\Untitled 2.png)

#### Control Plane

- 클러스터 환경 전반에 관한 결정(스케쥴링) 및 이벤트 감지
- 워커노드들의 상태를 관리하고 제어
- `kube-apiserver` : 쿠버네티스 API를 노출하는 컴포넌트
- `etcd` : 클러스터 데이터 저장소 (키-값 저장소)
- `kube-scheduler` : 새로운 작업에 대해 노드가 배정돼 있지 않을 경우, 실행할 노드 선택
- `kube-controller-manager` : 분리돼 있는 각 컴포넌프를 단일 프로세스 내에서 실행



#### CNI(Container Network Interface)

- 각 node에서 운영되고 있는 컨테이너간 통신을 돕는 인터페이스
- VxLAN, Pod Network라고도 부름
- 다양한 플러그인 존재(플라넬, 칼리코, 위브넷, kube-router 등)



## 쿠버네티스 실습



### 웹에서 설치 없이 사용

1) **카타코다 쿠버네티스 플레이그라운드**

   - 1시간 무료 사용 가능

   - https://www.katacoda.com/courses/kubernetes/playground

   - Master node, worker node 각 1개 구성

   - 코드

     ```shell
     # 실행
     launch.sh
     
     # 환경 체크
     kubectl cluster-info
     
     # 각 node 정보 확인
     kubectl get nodes
     ```

     

2. **Play with Kubernetes**

   - dokcker에서 제공해주는 쿠버네티스 연습장, docker hub 계정으로 로그인

   - https://labs.play-with-k8s.com

   - 4시간 사용 가능

   - Mater, worker Node 직접 구성한 후 사용가능

   - 실습

     1. `instance` 실행 ==> node 생성

     2. node1을 master node로 만들기
        ① `Initialize cluster master node`

        - Control Plane컴포넌트 구성 (Controller, scheduler, coreDNS, etcd 세팅)

        ```shell
        kubeadm init --apiserver-advertise-address $(hostname -i) --pod-network-cidr 10.5.0.0/16
        ```

        ② `CNI(Container Network Interface)` kube-router 세팅

        ```shell
        kubectl apply -f https://raw.githubusercontent.com/cloudnativelabs/kube-router/master/daemonset/kubeadm-kuberouter.yaml
        ```

        ③ worker node join 

        ```shell
        kubeadm join 192.168.0.23:6443 --token ctjkwa.soft30d86cvu7jb8 \
            --discovery-token-ca-cert-hash sha256:5229d0bdecc1e7ef6422746c94e37f34482d9da5a996a394f6c65eb1edc7b55b
        ```

        ④ cluster 확인

        ```shell
        kubectl get nodes -o wide
        ```

        ![image-20220311101356732](C:\Users\dad04\Desktop\LSH\TIL\Kubernetes\md-images\image-20220311101356732.png)

        



### 직접 설치

- OS : Window 10
- hyperviser : virtualbox (Oracle)
- Ubuntu 20.04
- master node1, worker node 2



#### VM 위 쿠버네티스 클러스터 세팅 순서

1. 모든 node에 Docker 설치

   - 패키지 업데이트

     ```shell
     sudo apt-get update
     
     sudo apt-get install -y \
     	ca-cetificates \
     	curl \
     	gnupg \
     	lsb-release
     ```

   - Docker의 GPG 키 설치

     ```shell
     curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
     ```

   - stable repository 등록

     ```shell
     echo \
       "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
       $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
     ```

   - update 후 docker CLI 설치

     ```shell
     sudo apt-get update
     sudo apt-get install docker-ce-cli containerd.io
     ```

     

2. Kubernetes 설치 전 환경설정

3. Kubernetes 설치

4. kubeadm, kubectl, kubelet 설치

5. control-plane 구성

6. worker node 구성

7. 설치 확인